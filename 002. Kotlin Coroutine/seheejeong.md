## Coroutines Basic
> 프로세스, 스레드의 개념을 익혀보면서 코루틴이 어디서 동작하는지, 이들과 어떤 차이가 있는지 알아보자.

`프로세스`란 실행 중인 어플리케이션의 인스턴스이다. 어플리케이션은 여러 프로세스로 구성될 수 있다. 프로세스는 상태를 가지고 있고 리소스를 여는 핸들, 데이터, 네트워크 연결 등은 프로세스 상태의 일부이며 해당 프로세스 내부의 스레드가 엑세스를 할 수 있다.

`스레드`란 프로세스가 실행할 일련의 명령을 포함한다. 그래서 프로세스는 최소한 하나의 스레드를 포함하며 이 스레드는 어플리케이션의 진입점을 실행하기 위해 생성된다. 스레드 안에서 명령은 한 번에 하나씩 실행되어 스레드가 Block이 되면, Block이 끝날 때까지 같은 스레드에서 다른 명령을 실행할 수 없다. 

`코루틴`은 `경량 스레드` 라고 하며, 스레드와 비슷한 라이프사이클을 가지고 있다. 코루틴은 스레드 안에서 실행된다. 스레드 하나에 많은 코루틴이 있을 수 있지만 주어진 시간에 하나의 스레드에서 하나의 명령만이 실행될 수 있다. 예시로, 같은 스레드에 10개의 코루틴이 있다면, 해당 시점에는 하나의 코루틴만 실행된다.

스레드와 코루틴의 가장 큰 차이점은, 코루틴은 빠르고 적은 비용으로 생성할 수 있다는 것이다. 수천개의 코루틴을 쉽게 생성할 수 있으며 수천개의 스레드를 생성하는 것보다 빠르고 자원도 적게 사용된다. 

코루틴은 특정 스레드안에서 실행되더라도, 스레드와 묶이지 않는다는 점을 이해해야한다. 코루틴의 일부를 특정 스레드에서 실행하고 실행을 중지한 다음 나중에 다른 스레드에서 계속 실행하는 것이 가능하다. 코틀린이 실행 가능한 스레드로 코루틴을 이동시키기 때문이다. 

<img src="https://images.velog.io/images/jshme/post/22a5cfc2-5457-4b01-b376-87d40d3e2be1/IMG_5031E3C6F5E9-1.jpeg" width="100%">

위 설명을 그림으로 다시 정리해보자면, 각 코루틴`(A, B, C)` 는 특정 스레드에서 시작되지만 어느 시점이 지나 다른 스레드에서 다시 시작되는 것을 확인할 수 있을 것이다. 


###  코루틴은 동시성 프로그래밍을 지원한다.
병렬성은 실제로 동시에 여러 작업을 처리되는 것이고, 동시성은 한번에 하나의 일만 처리하지만, 잦은 스위칭이 일어나면서 여러 일을 처리하기 때문에 동시에 여러 작업이 처리되는 것처럼 보인다. 

올바른 동시성 코드는 `결정론적인 결과`를 갖지만 실행 순서에는 약간의 가변성을 허용하는 것이다. 
> 결정론적 : 특정 입력이 들어오면 언제나 똑같은 과정을 거쳐서 항상 똑같은 결과를 내놓는다.

동시성을 이해하는 가장 좋은 방법은 순차적인 코드를 동시성과 비교하는 것이다. 
먼저 아래와 같은 비동시성 코드가 있다고 가정해보자.

![](https://images.velog.io/images/jshme/post/2d0f9e07-6e77-4f0f-ae7e-04f42abf3992/image.png)

`사용자의 정보 (userInfo)` 와 `연락처 정보 (contactInfo)` 를 순차적으로 실행하고, 프로필을 만들게 된다. 하지만 이러한 코드의 문제점이 두가지가 존재한다.
`getUserInfo` 와 `getContactInfo` 가 둘다 웹 서비스를 호출하고, 반환하는데 1초이상 소요된다면 `getProfile`은 항상 2초 이상 걸릴 것이다. 
이 때 `getUserInfo` 와 `getContactInfo` 는 서로 의존적이지 않기 때문에 이들을 동시에 호출한다면, `getProfile` 의 실행시간을 절반으로 줄일 수 있을 것이다.

![](https://images.velog.io/images/jshme/post/2449d653-4ea5-48bc-8039-eba976dafb62/image.png)

코루틴을 이용해서, 비동기적으로 변경한 모습이며 위 코드는 두 요청이 거의 동시에 시작될 것이다. 두 함수의 `await()` 를 호출하여 둘다 완료될 때에만 `createProfile` 을 실행하도록 한다면, 어떤 호출이 먼저 종료되는지에 관계없이 `getProfile` 의 결과가 결정론적임을 보장할 수 있다. 


### 스레드 생성

코틀린은 스레드 생성과정을 단순화해서 쉽고 간단하게 스레드를 생성할 수 있다. 코틀린에서는 스레드와 스레드 풀을 쉽게 만들 수 있지만, 직접 에세스하거나 제어하지 않는다는 점을 알아야 한다. 여기서는 CoroutieDispatcher를 만들어야 하는데, 이것은 기본적으로 가용성, 부하, 설정을 기반으로 스레드간에 코루틴을 분산하는 오케스트레이터이다. 디스패처가 만들어지면 이를 사용하는 코루틴을 시작할 수 있다. 


### async
결과 처리를 위한 목적으로 코루틴을 시작했다면 async() 를 사용해야 한다. async()는 Deferred<T> 를 반환하게 되는데, 이는 취소 불가능한 Non-Blocking Cancellable Future를 의미한다.

![](https://images.velog.io/images/jshme/post/8f9e0670-9c47-470a-b3e9-3687ac0b473e/image.png)

위는 예외를 던지는 함수인 `doSomething()`과, `async()` 를 통해 task를 실행하는 코드이다. `join()`을 통해 task를 실행하게 되면 에러가 발생하지 않고 성공적으로 실행되지만 `await()`를 통해 실행하게되면 에러가 발생하면서 종료하게된다. await()의 경우 예외를 감싸지 않고 전파하기 때문에 `unwrapping deferred` 라고 불린다.
이처럼 join()으로 대기한 후 검증하고 오류를 처리하는 것과 await()를 직접 호출하는 방식의 차이는 예외 전파의 유무라고 할 수 있다.

### launch
결과를 반환하지 않는 코루틴을 시작하려면 luanch() 를 사용해야 한다. launch()는 연산이 실패한 경우에만 통보를 받기 원하는 Fire and Forget 시나리오를 위해 설계되었다. 

  ![](https://images.velog.io/images/jshme/post/c2b19bcc-40d3-4ea2-a24d-2a33f6c2338d/image.png)
위 코드를 launch로 바꿔 실행하게 된다면, 예외가 발생하지만 실행은 중단되지 않고 성공적으로 완료하게 된다. 


### Job
Job 은 Fire and Forget 작업이다. 한번 시작된 작업은 예외가 발생하지 않는 한 대기하지 않는다. 기본적으로 job 내부에서 발생하는 예외는 job을 생성한 곳까지 전파되기 때문에, 완료되기를 기다리지 않아도 발생한다.

  ![](https://images.velog.io/images/jshme/post/f574e7b9-5584-48c3-8b5c-f03b42387966/KakaoTalk_Photo_2021-04-12-23-22-57.jpeg)

  1. 생성
    job은 기본적으로 launch()나 job()을 사용해 생성될 때 자동으로 시작되고, 자동으로 시작되지 않게 하려면 `CoroutineStart.LAZY`를 사용해야 한다. 
  
  2. 활성
 활성상태에 있는 job은 다양한 방법으로 시작할 수 있지만 일반적으로 start(), join()을 이용해서 실행하는데, 둘의 차이점은 전자의 경우 job이 완료될 때까지 기다리지 않고 job을 시작하는 반면 후자는 job이 완료될 때까지 일시 중단한다는 점이다. 그래서 start()의 경우는 suspend 함수에서 호출하지 않아도 되고, join()의 경우 실행을 일시중단할 수 있기 때문에 suspend 함수 내부에서 호출해야 한다.
  
 3. 취소 중
 취소 요청을 받은 활성 job은 취소중이라는 스테이징 상태로 들어갈 수 있다.

 4. 취소됨
 취소 또는 처리되지않은 예외로 인해 실행이 종료된 잡은 취소됨으로 간주된다.

  

### Job의 상태는 한 방향으로만 이동한다.
![](https://images.velog.io/images/jshme/post/86c88042-5eeb-4eb9-98cb-cb04a2a021dd/image.png)
Job은 특정 상태에 도달하면 이전 상태로 되돌아가지 않는다. 
위 코드에서 처음 호출한 job.join()이 완료되면 `완료됨` 상태에 도달했으므로 start()를 호출해도 아무런 변화가 없을 것이다. 


### Coroutine Context 
코루틴은 항상 컨텍스트 안에서 실행된다. 컨텍스트는 코루틴이 어떻게 실행되고 동작해야 하는지를 정의할 수 있게 해주는 요소들의 그룹이다. 컨텍스트는 또한 결합된 동작을 정의해 작동하기도한다. 